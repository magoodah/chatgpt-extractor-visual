<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse Grid - ChatGPT Prompt Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a365d 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Header Statistics */
        .stats-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            gap: 40px;
            z-index: 10;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.8;
        }

        /* Avatar Styles */
        .avatar {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #60a5fa;
            box-shadow: 0 0 20px rgba(96, 165, 250, 0.8), 0 0 40px rgba(96, 165, 250, 0.4);
            object-fit: cover;
            pointer-events: none;
            z-index: 5;
            transition: all 0.3s ease;
        }

        .avatar-pulse {
            animation: avatarPulse 2s ease-in-out infinite;
        }

        .avatar-burst {
            animation: avatarBurst 0.8s ease-out;
        }

        @keyframes avatarPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(96, 165, 250, 0.8), 0 0 40px rgba(96, 165, 250, 0.4);
            }
            50% { 
                transform: scale(1.08);
                box-shadow: 0 0 30px rgba(96, 165, 250, 1), 0 0 60px rgba(96, 165, 250, 0.6);
            }
        }

        @keyframes avatarBurst {
            0% {
                transform: scale(0.8);
                box-shadow: 0 0 5px rgba(96, 165, 250, 0.3);
            }
            50% {
                transform: scale(1.2);
                box-shadow: 0 0 40px rgba(96, 165, 250, 1), 0 0 80px rgba(96, 165, 250, 0.8);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(96, 165, 250, 0.8), 0 0 40px rgba(96, 165, 250, 0.4);
            }
        }

        /* Particle Effects */
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(96, 165, 250, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
        }

        /* Prompt Display */
        .prompt-display {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            min-height: 100px;
            max-height: 300px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 10;
            transition: height 0.3s ease-out;
        }

        .prompt-text {
            font-size: 18px;
            max-width: 90%;
            text-align: center;
            line-height: 1.4;
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease-out;
            padding: 0 10px;
        }

        .prompt-text.show {
            transform: translateY(0);
            opacity: 1;
        }

        .prompt-text.short {
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            max-height: none;
        }

        .prompt-text.medium {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            white-space: normal;
        }

        .prompt-text.long {
            white-space: normal;
            overflow-y: auto;
        }

        .prompt-text::-webkit-scrollbar {
            width: 4px;
        }

        .prompt-text::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .prompt-text::-webkit-scrollbar-thumb {
            background: rgba(96, 165, 250, 0.6);
            border-radius: 2px;
        }

        .prompt-text::-webkit-scrollbar-thumb:hover {
            background: rgba(96, 165, 250, 0.8);
        }

        .prompt-user {
            font-size: 14px;
            opacity: 0.7;
            margin-top: 10px;
            transform: translateY(10px);
            transition: all 0.5s ease-out 0.2s;
        }

        .prompt-user.show {
            transform: translateY(0);
            opacity: 0.7;
        }

        .prompt-length-indicator {
            font-size: 12px;
            opacity: 0.5;
            margin-top: 5px;
            display: none;
        }

        .prompt-length-indicator.show {
            display: block;
        }

        /* Settings Panel */
        .settings-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            z-index: 15;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
        }

        .settings-panel.show {
            transform: translateX(0);
        }

        .settings-toggle {
            position: absolute;
            top: 100px;
            right: -40px;
            width: 40px;
            height: 40px;
            background: rgba(96, 165, 250, 0.8);
            border: none;
            border-radius: 8px 0 0 8px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            z-index: 16;
            transition: background 0.3s ease;
        }

        .settings-toggle:hover {
            background: rgba(96, 165, 250, 1);
        }

        /* Background Particles */
        .background-particle {
            position: absolute;
            width: 1px;
            height: 1px;
            background: rgba(96, 165, 250, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
        }

        .settings-panel h3 {
            margin-bottom: 15px;
            color: #60a5fa;
        }

        .setting-item {
            margin-bottom: 10px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .setting-item input[type="range"] {
            width: 100%;
        }

        .setting-item input[type="checkbox"] {
            margin-right: 5px;
        }

        /* Activity Indicator */
        .activity-indicator {
            position: absolute;
            bottom: 120px;
            right: 20px;
            width: 200px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            z-index: 10;
        }

        .activity-bar {
            height: 5px;
            background: #60a5fa;
            border-radius: 3px;
            transition: width 0.3s ease;
            margin-top: 5px;
        }

        /* Loading Screen */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
        }

        .loading.hidden {
            display: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(96, 165, 250, 0.3);
            border-top-color: #60a5fa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div>Initializing Pulse Grid...</div>
    </div>

    <!-- Statistics Header -->
    <div class="stats-header">
        <div class="stat-item">
            <div class="stat-value" id="totalPrompts">0</div>
            <div class="stat-label">Total Prompts Today</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="activeUsers">0</div>
            <div class="stat-label">Active Users</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="promptsPerMinute">0</div>
            <div class="stat-label">Prompts/Minute</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="peakActivity">--:--</div>
            <div class="stat-label">Peak Activity</div>
        </div>
    </div>

    <!-- Main Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Prompt Display -->
    <div class="prompt-display">
        <div class="prompt-text" id="promptText"></div>
        <div class="prompt-user" id="promptUser"></div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <button class="settings-toggle" id="settingsToggle">⚙️</button>
        <h3>Settings</h3>
        <div class="setting-item">
            <label for="rippleSpeed">Ripple Speed</label>
            <input type="range" id="rippleSpeed" min="0.5" max="2" step="0.1" value="1">
        </div>
        <div class="setting-item">
            <label for="gridDensity">Grid Density</label>
            <input type="range" id="gridDensity" min="20" max="50" step="5" value="30">
        </div>
        <div class="setting-item">
            <label>
                <input type="checkbox" id="showAvatars" checked>
                Show Avatars
            </label>
        </div>
        <div class="setting-item">
            <label>
                <input type="checkbox" id="particleEffects" checked>
                Particle Effects
            </label>
        </div>
    </div>

    <!-- Activity Indicator -->
    <div class="activity-indicator">
        <div>Activity Level</div>
        <div class="activity-bar" id="activityBar"></div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script>

    <script>
        // Configuration
        const CONFIG = {
            GRID_COLS: 50,
            GRID_ROWS: 30,
            NODE_RADIUS: 3,
            NODE_BASE_COLOR: '#2563eb',
            NODE_ACTIVE_COLOR: '#60a5fa',
            NODE_BASE_OPACITY: 0.3,
            NODE_GLOW_INTENSITY: 0.8,
            RIPPLE_SPEED: 5, // nodes per second
            RIPPLE_MAX_RADIUS: 15,
            RIPPLE_DURATION: 3000,
            RIPPLE_FADE_DURATION: 2000,
            AVATAR_SIZE: 60,
            AVATAR_DISPLAY_DURATION: 5000,
            MAX_ACTIVE_RIPPLES: 10,
            PROMPT_DISPLAY_DURATION: 5000,
            GRID_BREATHING_SPEED: 0.0008,
            GRID_BREATHING_INTENSITY: 0.15,
            PARTICLE_COUNT: 30,
            EASING_POWER: 2.5
        };

        // Grid Manager
        class GridManager {
            constructor(canvas, cols, rows) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.cols = cols;
                this.rows = rows;
                this.nodes = [];
                this.nodeSpacing = 0;
                this.breathingPhase = 0;
                this.setupCanvas();
                this.initializeGrid();
            }

            setupCanvas() {
                const maxWidth = window.innerWidth * 0.9;
                const maxHeight = window.innerHeight * 0.7;
                
                this.nodeSpacing = Math.min(
                    maxWidth / (this.cols + 1),
                    maxHeight / (this.rows + 1)
                );
                
                this.canvas.width = this.nodeSpacing * (this.cols + 1);
                this.canvas.height = this.nodeSpacing * (this.rows + 1);
            }

            initializeGrid() {
                this.nodes = [];
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        this.nodes.push({
                            x: (col + 1) * this.nodeSpacing,
                            y: (row + 1) * this.nodeSpacing,
                            row,
                            col,
                            brightness: 0,
                            targetBrightness: 0
                        });
                    }
                }
            }

            getNodeAt(col, row) {
                if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) {
                    return null;
                }
                return this.nodes[row * this.cols + col];
            }

            getRandomNode() {
                const col = Math.floor(Math.random() * this.cols);
                const row = Math.floor(Math.random() * this.rows);
                return this.getNodeAt(col, row);
            }

            update(deltaTime) {
                // Update breathing phase
                this.breathingPhase += deltaTime * CONFIG.GRID_BREATHING_SPEED;
                
                // Update node brightnesses with smooth transitions
                this.nodes.forEach(node => {
                    const diff = node.targetBrightness - node.brightness;
                    node.brightness += diff * 0.08; // Slightly slower for more gradual recovery
                    
                    // Reset target brightness for idle state with gradual decay
                    if (node.targetBrightness > 0) {
                        node.targetBrightness *= 0.985; // Slower decay for smoother transitions
                    }
                });
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Calculate breathing effect
                const breathingIntensity = Math.sin(this.breathingPhase) * CONFIG.GRID_BREATHING_INTENSITY;
                
                this.nodes.forEach(node => {
                    // Add breathing effect to base opacity
                    const breathingOpacity = CONFIG.NODE_BASE_OPACITY * (1 + breathingIntensity);
                    const totalBrightness = Math.max(node.brightness, breathingOpacity);
                    const opacity = breathingOpacity + totalBrightness * (1 - breathingOpacity);
                    
                    const color = this.interpolateColor(CONFIG.NODE_BASE_COLOR, CONFIG.NODE_ACTIVE_COLOR, node.brightness);
                    
                    // Enhanced glow for all nodes
                    if (node.brightness > 0.05 || breathingIntensity > 0) {
                        const glowIntensity = Math.max(node.brightness * CONFIG.NODE_GLOW_INTENSITY, breathingIntensity * 0.3);
                        this.ctx.shadowBlur = 8 + (glowIntensity * 15);
                        this.ctx.shadowColor = CONFIG.NODE_ACTIVE_COLOR;
                    } else {
                        this.ctx.shadowBlur = 2;
                        this.ctx.shadowColor = CONFIG.NODE_BASE_COLOR;
                    }
                    
                    // Draw node with enhanced radius for active states
                    const nodeRadius = CONFIG.NODE_RADIUS + (node.brightness * 1.5);
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
                    this.ctx.fillStyle = color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                    this.ctx.fill();
                    
                    // Reset shadow
                    this.ctx.shadowBlur = 0;
                });
            }

            interpolateColor(color1, color2, factor) {
                const c1 = this.hexToRgb(color1);
                const c2 = this.hexToRgb(color2);
                
                const r = Math.round(c1.r + (c2.r - c1.r) * factor);
                const g = Math.round(c1.g + (c2.g - c1.g) * factor);
                const b = Math.round(c1.b + (c2.b - c1.b) * factor);
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
        }

        // Ripple Engine
        class RippleEngine {
            constructor(gridManager) {
                this.gridManager = gridManager;
                this.activeRipples = [];
                this.rippleQueue = [];
            }

            addRipple(centerNode, userData) {
                if (this.activeRipples.length >= CONFIG.MAX_ACTIVE_RIPPLES) {
                    this.rippleQueue.push({ centerNode, userData });
                    return;
                }

                const ripple = {
                    centerNode,
                    userData,
                    startTime: Date.now(),
                    radius: 0,
                    maxRadius: CONFIG.RIPPLE_MAX_RADIUS,
                    phase: 'expanding' // expanding, fading, complete
                };

                this.activeRipples.push(ripple);
                this.createAvatar(ripple);
            }

            createAvatar(ripple) {
                if (!document.getElementById('showAvatars').checked) return;

                const avatar = document.createElement('img');
                avatar.className = 'avatar avatar-pulse avatar-burst';
                avatar.src = ripple.userData.profilePicture || `https://ui-avatars.com/api/?name=${encodeURIComponent(ripple.userData.email)}&background=60a5fa&color=fff`;
                
                const rect = this.gridManager.canvas.getBoundingClientRect();
                avatar.style.left = rect.left + ripple.centerNode.x - CONFIG.AVATAR_SIZE / 2 + 'px';
                avatar.style.top = rect.top + ripple.centerNode.y - CONFIG.AVATAR_SIZE / 2 + 'px';
                
                document.body.appendChild(avatar);
                
                // Create particle burst effect
                this.createParticleBurst(ripple.centerNode, rect);
                
                // Fade in with burst animation
                avatar.style.opacity = '0';
                setTimeout(() => avatar.style.opacity = '1', 10);
                
                // Remove after display duration
                setTimeout(() => {
                    avatar.style.opacity = '0';
                    setTimeout(() => avatar.remove(), 1000);
                }, CONFIG.AVATAR_DISPLAY_DURATION);
            }

            createParticleBurst(centerNode, rect) {
                if (!document.getElementById('particleEffects').checked) return;
                
                for (let i = 0; i < 8; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    const angle = (i / 8) * Math.PI * 2;
                    const distance = 30 + Math.random() * 20;
                    const endX = centerNode.x + Math.cos(angle) * distance;
                    const endY = centerNode.y + Math.sin(angle) * distance;
                    
                    particle.style.left = rect.left + centerNode.x + 'px';
                    particle.style.top = rect.top + centerNode.y + 'px';
                    particle.style.opacity = '1';
                    
                    document.body.appendChild(particle);
                    
                    // Animate particle
                    setTimeout(() => {
                        particle.style.transition = 'all 0.8s ease-out';
                        particle.style.left = rect.left + endX + 'px';
                        particle.style.top = rect.top + endY + 'px';
                        particle.style.opacity = '0';
                        
                        setTimeout(() => particle.remove(), 800);
                    }, 10);
                }
            }

            update(deltaTime) {
                // Update active ripples
                this.activeRipples = this.activeRipples.filter(ripple => {
                    const elapsed = Date.now() - ripple.startTime;
                    
                    if (ripple.phase === 'expanding') {
                        // Use ease-out curve for more organic movement
                        const progress = elapsed / CONFIG.RIPPLE_DURATION;
                        const easedProgress = 1 - Math.pow(1 - progress, CONFIG.EASING_POWER);
                        ripple.radius = easedProgress * ripple.maxRadius * CONFIG.rippleSpeed;
                        
                        if (elapsed >= CONFIG.RIPPLE_DURATION) {
                            ripple.phase = 'fading';
                            ripple.fadeStartTime = Date.now();
                        }
                    } else if (ripple.phase === 'fading') {
                        const fadeElapsed = Date.now() - ripple.fadeStartTime;
                        if (fadeElapsed >= CONFIG.RIPPLE_FADE_DURATION) {
                            ripple.phase = 'complete';
                            return false;
                        }
                    }
                    
                    // Apply ripple effect to nodes
                    this.applyRippleToNodes(ripple);
                    return true;
                });
                
                // Process queue
                while (this.rippleQueue.length > 0 && this.activeRipples.length < CONFIG.MAX_ACTIVE_RIPPLES) {
                    const queued = this.rippleQueue.shift();
                    this.addRipple(queued.centerNode, queued.userData);
                }
            }

            applyRippleToNodes(ripple) {
                const { col: centerCol, row: centerRow } = ripple.centerNode;
                const currentRadius = Math.floor(ripple.radius);
                
                for (let r = -currentRadius; r <= currentRadius; r++) {
                    for (let c = -currentRadius; c <= currentRadius; c++) {
                        const distance = Math.sqrt(r * r + c * c);
                        if (distance <= ripple.radius) {
                            const node = this.gridManager.getNodeAt(centerCol + c, centerRow + r);
                            if (node) {
                                // Dramatic brightness falloff - brightest at center, fading more gradually
                                const normalizedDistance = distance / ripple.maxRadius;
                                const intensity = Math.max(0, 1 - Math.pow(normalizedDistance, 1.5));
                                
                                // Add extra brightness for center nodes
                                const centerBoost = distance < 2 ? (2 - distance) * 0.5 : 0;
                                let brightness = intensity + centerBoost;
                                
                                if (ripple.phase === 'fading') {
                                    const fadeProgress = (Date.now() - ripple.fadeStartTime) / CONFIG.RIPPLE_FADE_DURATION;
                                    const easedFade = Math.pow(fadeProgress, 0.8); // Slower fade start
                                    brightness *= (1 - easedFade);
                                }
                                
                                // Additive brightness for overlapping ripples
                                node.targetBrightness = Math.min(1, node.targetBrightness + brightness * 0.8);
                            }
                        }
                    }
                }
            }
        }

        // Statistics Manager
        class StatisticsManager {
            constructor() {
                this.stats = {
                    totalPromptsToday: 0,
                    activeUsers: new Set(),
                    promptTimestamps: [],
                    peakActivity: { time: null, count: 0 }
                };
                this.updateUI();
            }

            addPrompt(userData) {
                this.stats.totalPromptsToday++;
                this.stats.activeUsers.add(userData.email);
                this.stats.promptTimestamps.push(Date.now());
                
                // Clean old timestamps (older than 1 hour)
                const oneHourAgo = Date.now() - 3600000;
                this.stats.promptTimestamps = this.stats.promptTimestamps.filter(ts => ts > oneHourAgo);
                
                // Update peak activity
                const currentHour = new Date().getHours();
                const promptsThisHour = this.stats.promptTimestamps.filter(ts => {
                    return new Date(ts).getHours() === currentHour;
                }).length;
                
                if (promptsThisHour > this.stats.peakActivity.count) {
                    this.stats.peakActivity = {
                        time: `${currentHour}:00`,
                        count: promptsThisHour
                    };
                }
                
                this.updateUI();
                this.updateActivityBar();
            }

            getPromptsPerMinute() {
                const oneMinuteAgo = Date.now() - 60000;
                const recentPrompts = this.stats.promptTimestamps.filter(ts => ts > oneMinuteAgo);
                return recentPrompts.length;
            }

            updateUI() {
                document.getElementById('totalPrompts').textContent = this.stats.totalPromptsToday;
                document.getElementById('activeUsers').textContent = this.stats.activeUsers.size;
                document.getElementById('promptsPerMinute').textContent = this.getPromptsPerMinute().toFixed(1);
                document.getElementById('peakActivity').textContent = this.stats.peakActivity.time || '--:--';
            }

            updateActivityBar() {
                const activity = Math.min(this.getPromptsPerMinute() / 10, 1);
                document.getElementById('activityBar').style.width = `${activity * 100}%`;
            }
        }

        // Prompt Display Controller
        class PromptDisplayController {
            constructor() {
                this.currentPrompt = null;
                this.displayTimeout = null;
            }

            showPrompt(userData) {
                // Clear existing timeout
                if (this.displayTimeout) {
                    clearTimeout(this.displayTimeout);
                }
                
                const promptTextEl = document.getElementById('promptText');
                const promptUserEl = document.getElementById('promptUser');
                const promptDisplay = document.querySelector('.prompt-display');
                
                // Hide current content
                promptTextEl.classList.remove('show');
                promptUserEl.classList.remove('show');
                
                setTimeout(() => {
                    const promptText = userData.content || 'New prompt';
                    let displayText = promptText;
                    let lengthClass = 'short';
                    
                    // Determine how to display based on length
                    if (promptText.length <= 80) {
                        // Short prompts - single line with ellipsis
                        lengthClass = 'short';
                        displayText = promptText.length > 80 ? promptText.substring(0, 80) + '...' : promptText;
                    } else if (promptText.length <= 300) {
                        // Medium prompts - 3 lines max
                        lengthClass = 'medium';
                        displayText = promptText;
                    } else {
                        // Long prompts - scrollable area
                        lengthClass = 'long';
                        displayText = promptText;
                        
                        // Adjust display height for long prompts
                        promptDisplay.style.minHeight = '180px';
                    }
                    
                    // Remove previous length classes
                    promptTextEl.classList.remove('short', 'medium', 'long');
                    promptTextEl.classList.add(lengthClass);
                    
                    promptTextEl.textContent = displayText;
                    promptUserEl.textContent = userData.email || 'Anonymous';
                    
                    // Show with animation
                    promptTextEl.classList.add('show');
                    promptUserEl.classList.add('show');
                }, 100);
                
                // Longer display time for longer prompts
                const displayDuration = Math.min(CONFIG.PROMPT_DISPLAY_DURATION + (userData.content?.length || 0) * 20, 15000);
                
                // Auto-hide after duration
                this.displayTimeout = setTimeout(() => {
                    promptTextEl.classList.remove('show');
                    promptUserEl.classList.remove('show');
                    setTimeout(() => {
                        promptTextEl.textContent = '';
                        promptUserEl.textContent = '';
                        promptDisplay.style.minHeight = '100px'; // Reset height
                        promptTextEl.classList.remove('short', 'medium', 'long');
                    }, 500);
                }, displayDuration);
            }
        }

        // Background Particle System
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.createParticles();
            }

            createParticles() {
                for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                    this.createParticle();
                }
            }

            createParticle() {
                const particle = document.createElement('div');
                particle.className = 'background-particle';
                
                // Random position
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.top = Math.random() * window.innerHeight + 'px';
                
                // Random size
                const size = 1 + Math.random() * 2;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                
                // Random opacity
                particle.style.opacity = 0.1 + Math.random() * 0.3;
                
                document.body.appendChild(particle);
                
                // Animate
                this.animateParticle(particle);
                
                this.particles.push(particle);
            }

            animateParticle(particle) {
                const duration = 20000 + Math.random() * 10000;
                const startX = parseFloat(particle.style.left);
                const startY = parseFloat(particle.style.top);
                const endX = startX + (Math.random() - 0.5) * 200;
                const endY = startY - 100 - Math.random() * 200;
                
                particle.style.transition = `all ${duration}ms linear`;
                particle.style.left = endX + 'px';
                particle.style.top = endY + 'px';
                particle.style.opacity = '0';
                
                setTimeout(() => {
                    particle.remove();
                    this.particles = this.particles.filter(p => p !== particle);
                    
                    // Create new particle
                    if (document.getElementById('particleEffects').checked) {
                        this.createParticle();
                    }
                }, duration);
            }

            toggle(enabled) {
                if (!enabled) {
                    this.particles.forEach(particle => particle.remove());
                    this.particles = [];
                } else {
                    this.createParticles();
                }
            }
        }

        // Main Application
        class PulseGridApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gridManager = new GridManager(this.canvas, CONFIG.GRID_COLS, CONFIG.GRID_ROWS);
                this.rippleEngine = new RippleEngine(this.gridManager);
                this.statsManager = new StatisticsManager();
                this.promptDisplay = new PromptDisplayController();
                this.particleSystem = new ParticleSystem();
                this.lastFrameTime = 0;
                this.isRunning = true;
                
                // Settings
                this.rippleSpeed = 1;
                
                this.initializeSettings();
                this.initializeFirebase();
                this.startAnimationLoop();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('settingsPanel').classList.add('show');
                }, 1000);
                
                // Demo mode - generate test data
                this.startDemoMode();
            }

            initializeSettings() {
                // Settings panel toggle
                document.getElementById('settingsToggle').addEventListener('click', () => {
                    const panel = document.getElementById('settingsPanel');
                    panel.classList.toggle('show');
                });
                
                // Ripple speed control
                document.getElementById('rippleSpeed').addEventListener('input', (e) => {
                    CONFIG.rippleSpeed = parseFloat(e.target.value);
                });
                
                // Grid density control
                document.getElementById('gridDensity').addEventListener('input', (e) => {
                    const density = parseInt(e.target.value);
                    CONFIG.GRID_ROWS = density;
                    CONFIG.GRID_COLS = Math.floor(density * 1.67); // Maintain aspect ratio
                    this.gridManager = new GridManager(this.canvas, CONFIG.GRID_COLS, CONFIG.GRID_ROWS);
                    this.rippleEngine = new RippleEngine(this.gridManager);
                });
                
                // Particle effects toggle
                document.getElementById('particleEffects').addEventListener('change', (e) => {
                    this.particleSystem.toggle(e.target.checked);
                });
                
                // Window resize handler
                window.addEventListener('resize', () => {
                    this.gridManager.setupCanvas();
                    this.gridManager.initializeGrid();
                });
            }

            initializeFirebase() {
                // Firebase configuration (replace with your config)
                const firebaseConfig = {
                    apiKey: "YOUR_API_KEY",
                    authDomain: "YOUR_AUTH_DOMAIN",
                    databaseURL: "YOUR_DATABASE_URL",
                    projectId: "YOUR_PROJECT_ID",
                    storageBucket: "YOUR_STORAGE_BUCKET",
                    messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
                    appId: "YOUR_APP_ID"
                };
                
                // Uncomment these lines when you have Firebase configured
                // firebase.initializeApp(firebaseConfig);
                // const database = firebase.database();
                
                // Listen for new prompts
                // database.ref('prompts').on('child_added', (snapshot) => {
                //     const promptData = snapshot.val();
                //     this.handleNewPrompt(promptData);
                // });
            }

            handleNewPrompt(userData) {
                // Add to statistics
                this.statsManager.addPrompt(userData);
                
                // Create ripple at random position
                const centerNode = this.gridManager.getRandomNode();
                this.rippleEngine.addRipple(centerNode, userData);
                
                // Display prompt
                this.promptDisplay.showPrompt(userData);
                
                // Special effects for milestones
                if (this.statsManager.stats.totalPromptsToday % 100 === 0) {
                    this.triggerMilestoneEffect();
                }
            }

            triggerMilestoneEffect() {
                // Create spectacular wave effect from center outward
                const centerCol = Math.floor(CONFIG.GRID_COLS / 2);
                const centerRow = Math.floor(CONFIG.GRID_ROWS / 2);
                const maxDistance = Math.sqrt(centerCol * centerCol + centerRow * centerRow);
                
                // Create expanding rings
                let ring = 0;
                const createRing = () => {
                    this.gridManager.nodes.forEach(node => {
                        const distance = Math.sqrt(
                            Math.pow(node.col - centerCol, 2) + Math.pow(node.row - centerRow, 2)
                        );
                        
                        if (Math.abs(distance - ring) < 2) {
                            node.targetBrightness = 1;
                        }
                    });
                    
                    ring += 2;
                    if (ring < maxDistance) {
                        setTimeout(createRing, 100);
                    }
                };
                
                createRing();
                
                // Add celebration text
                const celebration = document.createElement('div');
                celebration.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 48px;
                    font-weight: bold;
                    color: #60a5fa;
                    text-shadow: 0 0 20px rgba(96, 165, 250, 0.8);
                    z-index: 100;
                    pointer-events: none;
                    animation: celebration 2s ease-out forwards;
                `;
                celebration.textContent = `🎉 ${this.statsManager.stats.totalPromptsToday} Prompts! 🎉`;
                document.body.appendChild(celebration);
                
                // Add celebration animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes celebration {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                        50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                    }
                `;
                document.head.appendChild(style);
                
                setTimeout(() => {
                    celebration.remove();
                    style.remove();
                }, 2000);
            }

            startAnimationLoop() {
                const animate = (currentTime) => {
                    if (!this.isRunning) return;
                    
                    const deltaTime = currentTime - this.lastFrameTime;
                    this.lastFrameTime = currentTime;
                    
                    // Update components
                    this.gridManager.update(deltaTime);
                    this.rippleEngine.update(deltaTime);
                    
                    // Render
                    this.gridManager.render();
                    
                    requestAnimationFrame(animate);
                };
                
                requestAnimationFrame(animate);
            }

            // Demo mode for testing without Firebase
            startDemoMode() {
                const demoUsers = [
                    { email: 'alice@deloitte.com', profilePicture: 'public/img/testimonial-1.png' },
                    { email: 'bob@deloitte.com', profilePicture: 'public/img/testimonial-2.png' },
                    { email: 'carol@deloitte.com', profilePicture: 'public/img/testimonial-3.png' },
                    { email: 'david@deloitte.com', profilePicture: 'public/img/testimonial-1.png' },
                    { email: 'emma@deloitte.com', profilePicture: 'public/img/testimonial-2.png' }
                ];
                
                const demoPrompts = [
                    'How can we optimize our supply chain using AI?',
                    'Generate a quarterly report template for client presentations',
                    'What are the latest trends in digital transformation?',
                    'Create a comprehensive risk assessment framework for cybersecurity that includes threat modeling, vulnerability analysis, incident response procedures, and compliance requirements for SOC 2, ISO 27001, and GDPR regulations. The framework should address both technical and organizational security measures.',
                    'Analyze the impact of remote work on productivity',
                    'Develop a detailed sustainability strategy for manufacturing operations that encompasses carbon footprint reduction, waste management optimization, renewable energy adoption, sustainable supply chain practices, and circular economy principles. Include specific KPIs, timeline milestones, and budget allocation recommendations for the next 5 years.',
                    'What are best practices for data governance?',
                    'Design a customer journey map for our new service',
                    'Please help me create a comprehensive digital transformation roadmap for a traditional retail company transitioning to omnichannel commerce. This should include technology stack recommendations, organizational change management strategies, employee training programs, customer experience optimization, data analytics implementation, and integration with existing legacy systems. The plan needs to address both short-term quick wins and long-term strategic objectives while considering budget constraints and risk mitigation.',
                    'I need assistance developing a machine learning model for predictive maintenance in manufacturing equipment. The solution should incorporate IoT sensor data, historical maintenance records, environmental factors, and operational parameters to predict equipment failures before they occur. Please outline the data preprocessing steps, feature engineering approaches, model selection criteria, validation methodology, and deployment strategy including real-time monitoring capabilities.',
                    'Create a detailed employee onboarding program that covers the first 90 days of employment, including orientation activities, training modules, mentorship assignments, goal setting, performance check-ins, and integration with company culture. The program should be scalable across different departments and roles while maintaining consistency in core company values and compliance requirements.'
                ];
                
                // Generate random prompts
                setInterval(() => {
                    const user = demoUsers[Math.floor(Math.random() * demoUsers.length)];
                    const prompt = demoPrompts[Math.floor(Math.random() * demoPrompts.length)];
                    
                    this.handleNewPrompt({
                        ...user,
                        content: prompt,
                        timestamp: Date.now()
                    });
                }, 3000 + Math.random() * 4000); // Random interval between 3-7 seconds
            }

            stop() {
                this.isRunning = false;
            }
        }

        // Initialize application when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.pulseGrid = new PulseGridApp();
        });
    </script>
</body>
</html>