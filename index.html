<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse Grid - ChatGPT Prompt Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a365d 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
            position: relative;
            display: flex;
        }

        .main-content {
            flex: 1;
            position: relative;
            transition: margin-left 0.3s ease-out;
        }

        .main-content.with-feed {
            margin-left: var(--feed-width, 320px);
        }

        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Header Statistics */
        .stats-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            gap: 40px;
            z-index: 10;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.8;
        }

        /* Avatar Styles */
        .avatar {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #60a5fa;
            box-shadow: 0 0 20px rgba(96, 165, 250, 0.8), 0 0 40px rgba(96, 165, 250, 0.4);
            object-fit: cover;
            pointer-events: none;
            z-index: 5;
            transition: all 0.3s ease;
        }

        .avatar-pulse {
            animation: avatarPulse 2s ease-in-out infinite;
        }

        .avatar-burst {
            animation: avatarBurst 0.8s ease-out;
        }

        @keyframes avatarPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(96, 165, 250, 0.8), 0 0 40px rgba(96, 165, 250, 0.4);
            }
            50% { 
                transform: scale(1.08);
                box-shadow: 0 0 30px rgba(96, 165, 250, 1), 0 0 60px rgba(96, 165, 250, 0.6);
            }
        }

        @keyframes avatarBurst {
            0% {
                transform: scale(0.8);
                box-shadow: 0 0 5px rgba(96, 165, 250, 0.3);
            }
            50% {
                transform: scale(1.2);
                box-shadow: 0 0 40px rgba(96, 165, 250, 1), 0 0 80px rgba(96, 165, 250, 0.8);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(96, 165, 250, 0.8), 0 0 40px rgba(96, 165, 250, 0.4);
            }
        }

        /* Particle Effects */
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(96, 165, 250, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
        }

        /* Prompt Display */
        .prompt-display {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            min-height: 80px;
            max-height: 200px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px;
            z-index: 10;
            transition: height 0.3s ease-out;
        }

        .prompt-text {
            font-size: 16px;
            max-width: 90%;
            text-align: center;
            line-height: 1.3;
            max-height: 120px;
            overflow-y: auto;
            overflow-x: hidden;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.5s ease-out;
            padding: 0 10px;
        }

        .prompt-text.show {
            transform: translateY(0);
            opacity: 1;
        }

        .prompt-text.short {
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            max-height: none;
        }

        .prompt-text.medium {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            white-space: normal;
        }

        .prompt-text.long {
            white-space: normal;
            overflow-y: auto;
        }

        .prompt-text::-webkit-scrollbar {
            width: 4px;
        }

        .prompt-text::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .prompt-text::-webkit-scrollbar-thumb {
            background: rgba(96, 165, 250, 0.6);
            border-radius: 2px;
        }

        .prompt-text::-webkit-scrollbar-thumb:hover {
            background: rgba(96, 165, 250, 0.8);
        }

        .prompt-user {
            font-size: 14px;
            opacity: 0.7;
            margin-top: 10px;
            transform: translateY(10px);
            transition: all 0.5s ease-out 0.2s;
        }

        .prompt-user.show {
            transform: translateY(0);
            opacity: 0.7;
        }

        .prompt-length-indicator {
            font-size: 12px;
            opacity: 0.5;
            margin-top: 5px;
            display: none;
        }

        .prompt-length-indicator.show {
            display: block;
        }

        /* Settings Panel */
        .settings-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            z-index: 15;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
        }

        .settings-panel.show {
            transform: translateX(0);
        }

        .settings-toggle {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(96, 165, 250, 0.8);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            z-index: 16;
            transition: all 0.3s ease;
        }

        .settings-toggle:hover {
            background: rgba(96, 165, 250, 1);
            transform: scale(1.05);
        }

        .settings-toggle.panel-open {
            right: 0px;
        }

        /* Background Particles */
        .background-particle {
            position: absolute;
            width: 1px;
            height: 1px;
            background: rgba(96, 165, 250, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
        }

        /* Prompt Feed Sidebar */
        .prompt-feed {
            position: fixed;
            left: 0;
            top: 0;
            width: 320px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(96, 165, 250, 0.2);
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.3);
            z-index: 5;
            transform: translateX(-100%);
            transition: transform 0.3s ease-out;
            overflow: hidden;
            min-width: 250px;
            max-width: 600px;
        }

        .prompt-feed.show {
            transform: translateX(0);
        }

        .prompt-feed.resizing {
            transition: none;
        }

        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            width: 5px;
            height: 100%;
            background: rgba(96, 165, 250, 0.3);
            cursor: ew-resize;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .resize-handle:hover {
            opacity: 1;
            background: rgba(96, 165, 250, 0.6);
        }

        .prompt-feed:hover .resize-handle {
            opacity: 0.7;
        }

        .prompt-feed-header {
            padding: 20px;
            border-bottom: 1px solid rgba(96, 165, 250, 0.2);
            background: rgba(96, 165, 250, 0.1);
        }

        .prompt-feed-title {
            font-size: 18px;
            font-weight: 600;
            color: #60a5fa;
            margin: 0;
        }

        .prompt-feed-subtitle {
            font-size: 12px;
            opacity: 0.7;
            margin: 5px 0 0 0;
        }

        .prompt-feed-toggle {
            position: fixed;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 80px;
            background: rgba(96, 165, 250, 0.8);
            border: none;
            border-radius: 0 12px 12px 0;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            z-index: 20;
        }

        .prompt-feed-toggle:hover {
            background: rgba(96, 165, 250, 1);
            left: 5px;
        }

        .prompt-feed-container {
            height: calc(100vh - 80px);
            overflow: hidden;
            position: relative;
        }

        .prompt-feed-scroll {
            height: 100%;
            overflow-y: hidden;
            padding: 0;
            position: relative;
        }

        .prompt-item {
            display: flex;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.05) 0%, rgba(96, 165, 250, 0.02) 100%);
            transform: translateY(0);
            opacity: 1;
        }

        .prompt-item.entering {
            transform: translateY(-20px);
            opacity: 0;
        }

        .prompt-item.exiting {
            transform: translateY(20px);
            opacity: 0;
        }

        .prompt-item:hover {
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.15) 0%, rgba(96, 165, 250, 0.08) 100%);
            transform: translateX(5px);
            box-shadow: 0 4px 20px rgba(96, 165, 250, 0.2);
        }

        .prompt-item.recent {
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.12) 0%, rgba(96, 165, 250, 0.06) 100%);
            transform: scale(1.02);
            box-shadow: 0 2px 15px rgba(96, 165, 250, 0.15);
        }

        .prompt-item.fading {
            opacity: 0.6;
        }

        .prompt-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(96, 165, 250, 0.6);
            margin-right: 12px;
            flex-shrink: 0;
            object-fit: cover;
            box-shadow: 0 2px 8px rgba(96, 165, 250, 0.3);
        }

        .prompt-content {
            flex: 1;
            min-width: 0;
        }

        .prompt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .prompt-user {
            font-size: 13px;
            font-weight: 500;
            color: #60a5fa;
            margin: 0;
        }

        .prompt-time {
            font-size: 11px;
            opacity: 0.6;
            white-space: nowrap;
        }

        .prompt-preview {
            font-size: 13px;
            line-height: 1.4;
            opacity: 0.85;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            margin: 0;
        }

        .settings-panel h3 {
            margin-bottom: 15px;
            color: #60a5fa;
        }

        .setting-item {
            margin-bottom: 10px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .setting-item input[type="range"] {
            width: 100%;
        }

        .setting-item input[type="checkbox"] {
            margin-right: 5px;
        }

        /* Activity Indicator */
        .activity-indicator {
            position: absolute;
            bottom: 120px;
            right: 20px;
            width: 200px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            z-index: 10;
            display: none;
        }

        .activity-bar {
            height: 5px;
            background: #60a5fa;
            border-radius: 3px;
            transition: width 0.3s ease;
            margin-top: 5px;
        }

        /* Loading Screen */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
        }

        .loading.hidden {
            display: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(96, 165, 250, 0.3);
            border-top-color: #60a5fa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Prompt Feed Sidebar -->
    <div class="prompt-feed" id="promptFeed">
        <div class="resize-handle" id="resizeHandle"></div>
        <button class="prompt-feed-toggle" id="promptFeedToggle">FEED</button>
        <div class="prompt-feed-header">
            <h3 class="prompt-feed-title">Live Prompts</h3>
            <p class="prompt-feed-subtitle">Real-time activity feed</p>
        </div>
        <div class="prompt-feed-container">
            <div class="prompt-feed-scroll" id="promptFeedScroll">
                <!-- Prompt items will be dynamically added here -->
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content" id="mainContent">
    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div>Initializing Pulse Grid...</div>
    </div>

    <!-- Statistics Header -->
    <div class="stats-header">
        <div class="stat-item">
            <div class="stat-value" id="totalPrompts">0</div>
            <div class="stat-label">Total Prompts Today</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="activeUsers">0</div>
            <div class="stat-label">Active Users</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="promptsPerMinute">0</div>
            <div class="stat-label">Prompts/Minute</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="peakActivity">--:--</div>
            <div class="stat-label">Peak Activity</div>
        </div>
    </div>

    <!-- Main Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Prompt Display -->
    <div class="prompt-display">
        <div class="prompt-text" id="promptText"></div>
        <div class="prompt-user" id="promptUser"></div>
    </div>

    <!-- Settings Toggle Button -->
    <button class="settings-toggle" id="settingsToggle">⚙️</button>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <h3>Settings</h3>
        <div class="setting-item">
            <label for="rippleSpeed">Ripple Speed</label>
            <input type="range" id="rippleSpeed" min="0.5" max="2" step="0.1" value="1.6">
        </div>
        <div class="setting-item">
            <label for="gridDensity">Grid Density</label>
            <input type="range" id="gridDensity" min="20" max="50" step="5" value="30">
        </div>
        <div class="setting-item">
            <label>
                <input type="checkbox" id="showAvatars" checked>
                Show Avatars
            </label>
        </div>
        <div class="setting-item">
            <label>
                <input type="checkbox" id="particleEffects" checked>
                Particle Effects
            </label>
        </div>
        <div class="setting-item">
            <button id="promptFeedToggleTemp" style="width: 100%; padding: 10px; background: #60a5fa; color: white; border: none; border-radius: 5px; cursor: pointer;">Toggle Prompt Feed</button>
        </div>
    </div>

    <!-- Activity Indicator -->
    <div class="activity-indicator">
        <div>Activity Level</div>
        <div class="activity-bar" id="activityBar"></div>
    </div>

    <!-- Firebase SDK v9 -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
        import { 
            getFirestore, 
            collection, 
            onSnapshot, 
            query, 
            orderBy, 
            limit,
            where
        } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';
        
        // Make Firebase available globally
        window.FirebaseApp = { initializeApp };
        window.FirebaseFirestore = { getFirestore, collection, onSnapshot, query, orderBy, limit, where };
    </script>

    <script>
        // Configuration
        const CONFIG = {
            GRID_COLS: 50,
            GRID_ROWS: 30,
            NODE_RADIUS: 3,
            NODE_BASE_COLOR: '#2563eb',
            NODE_ACTIVE_COLOR: '#60a5fa',
            NODE_BASE_OPACITY: 0.3,
            NODE_GLOW_INTENSITY: 0.8,
            RIPPLE_SPEED: 5, // nodes per second
            RIPPLE_MAX_RADIUS: 15,
            RIPPLE_DURATION: 3000,
            RIPPLE_FADE_DURATION: 2000,
            AVATAR_SIZE: 60,
            AVATAR_DISPLAY_DURATION: 5000,
            MAX_ACTIVE_RIPPLES: 10,
            PROMPT_DISPLAY_DURATION: 5000,
            GRID_BREATHING_SPEED: 0.0008,
            GRID_BREATHING_INTENSITY: 0.15,
            PARTICLE_COUNT: 30,
            EASING_POWER: 2.5,
            rippleSpeed: 1.6  // Default ripple speed (75% of range)
        };

        // Grid Manager
        class GridManager {
            constructor(canvas, cols, rows) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.cols = cols;
                this.rows = rows;
                this.nodes = [];
                this.nodeSpacing = 0;
                this.breathingPhase = 0;
                this.setupCanvas();
                this.initializeGrid();
            }

            setupCanvas() {
                const maxWidth = window.innerWidth * 0.9;
                const maxHeight = window.innerHeight * 0.7;
                
                this.nodeSpacing = Math.min(
                    maxWidth / (this.cols + 1),
                    maxHeight / (this.rows + 1)
                );
                
                this.canvas.width = this.nodeSpacing * (this.cols + 1);
                this.canvas.height = this.nodeSpacing * (this.rows + 1);
            }

            initializeGrid() {
                this.nodes = [];
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        this.nodes.push({
                            x: (col + 1) * this.nodeSpacing,
                            y: (row + 1) * this.nodeSpacing,
                            row,
                            col,
                            brightness: 0,
                            targetBrightness: 0
                        });
                    }
                }
            }

            getNodeAt(col, row) {
                if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) {
                    return null;
                }
                return this.nodes[row * this.cols + col];
            }

            getRandomNode() {
                const col = Math.floor(Math.random() * this.cols);
                const row = Math.floor(Math.random() * this.rows);
                return this.getNodeAt(col, row);
            }

            update(deltaTime) {
                // Update breathing phase
                this.breathingPhase += deltaTime * CONFIG.GRID_BREATHING_SPEED;
                
                // Update node brightnesses with smooth transitions
                this.nodes.forEach(node => {
                    const diff = node.targetBrightness - node.brightness;
                    node.brightness += diff * 0.08; // Slightly slower for more gradual recovery
                    
                    // Reset target brightness for idle state with gradual decay
                    if (node.targetBrightness > 0) {
                        node.targetBrightness *= 0.985; // Slower decay for smoother transitions
                    }
                });
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Calculate breathing effect
                const breathingIntensity = Math.sin(this.breathingPhase) * CONFIG.GRID_BREATHING_INTENSITY;
                
                this.nodes.forEach(node => {
                    // Add breathing effect to base opacity
                    const breathingOpacity = CONFIG.NODE_BASE_OPACITY * (1 + breathingIntensity);
                    const totalBrightness = Math.max(node.brightness, breathingOpacity);
                    const opacity = breathingOpacity + totalBrightness * (1 - breathingOpacity);
                    
                    const color = this.interpolateColor(CONFIG.NODE_BASE_COLOR, CONFIG.NODE_ACTIVE_COLOR, node.brightness);
                    
                    // Enhanced glow for all nodes
                    if (node.brightness > 0.05 || breathingIntensity > 0) {
                        const glowIntensity = Math.max(node.brightness * CONFIG.NODE_GLOW_INTENSITY, breathingIntensity * 0.3);
                        this.ctx.shadowBlur = 8 + (glowIntensity * 15);
                        this.ctx.shadowColor = CONFIG.NODE_ACTIVE_COLOR;
                    } else {
                        this.ctx.shadowBlur = 2;
                        this.ctx.shadowColor = CONFIG.NODE_BASE_COLOR;
                    }
                    
                    // Draw node with enhanced radius for active states
                    const nodeRadius = CONFIG.NODE_RADIUS + (node.brightness * 1.5);
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
                    this.ctx.fillStyle = color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                    this.ctx.fill();
                    
                    // Reset shadow
                    this.ctx.shadowBlur = 0;
                });
            }

            interpolateColor(color1, color2, factor) {
                const c1 = this.hexToRgb(color1);
                const c2 = this.hexToRgb(color2);
                
                const r = Math.round(c1.r + (c2.r - c1.r) * factor);
                const g = Math.round(c1.g + (c2.g - c1.g) * factor);
                const b = Math.round(c1.b + (c2.b - c1.b) * factor);
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
        }

        // Ripple Engine
        class RippleEngine {
            constructor(gridManager) {
                this.gridManager = gridManager;
                this.activeRipples = [];
                this.rippleQueue = [];
            }

            addRipple(centerNode, userData, intensity = 1) {
                if (this.activeRipples.length >= CONFIG.MAX_ACTIVE_RIPPLES) {
                    this.rippleQueue.push({ centerNode, userData, intensity });
                    return;
                }

                const ripple = {
                    centerNode,
                    userData,
                    startTime: Date.now(),
                    radius: 0,
                    maxRadius: CONFIG.RIPPLE_MAX_RADIUS * intensity,
                    phase: 'expanding', // expanding, fading, complete
                    type: userData.type || 'extraction',
                    intensity: intensity
                };

                this.activeRipples.push(ripple);
                this.createAvatar(ripple);
            }
            
            addFeedbackRipple(centerNode, feedbackData) {
                if (this.activeRipples.length >= CONFIG.MAX_ACTIVE_RIPPLES) {
                    this.rippleQueue.push({ centerNode, userData: feedbackData, type: 'feedback' });
                    return;
                }
                
                // Create smaller, colored ripple for feedback
                const ripple = {
                    centerNode,
                    userData: feedbackData,
                    startTime: Date.now(),
                    radius: 0,
                    maxRadius: Math.min(CONFIG.RIPPLE_MAX_RADIUS * 0.7, feedbackData.rating * 3), // Size based on rating
                    phase: 'expanding',
                    type: 'feedback',
                    intensity: feedbackData.rating / 5 // 0.2 - 1.0 based on 1-5 star rating
                };
                
                this.activeRipples.push(ripple);
                this.createFeedbackAvatar(ripple);
            }

            createAvatar(ripple) {
                if (!document.getElementById('showAvatars').checked) return;

                const avatar = document.createElement('img');
                avatar.className = 'avatar avatar-pulse avatar-burst';
                // Use the avatar generated by our system\n                avatar.src = ripple.userData.avatar || '/public/img/testimonial-1.png';
                
                const rect = this.gridManager.canvas.getBoundingClientRect();
                avatar.style.left = rect.left + ripple.centerNode.x - CONFIG.AVATAR_SIZE / 2 + 'px';
                avatar.style.top = rect.top + ripple.centerNode.y - CONFIG.AVATAR_SIZE / 2 + 'px';
                
                document.body.appendChild(avatar);
                
                // Create particle burst effect
                this.createParticleBurst(ripple.centerNode, rect);
                
                // Fade in with burst animation
                avatar.style.opacity = '0';
                setTimeout(() => avatar.style.opacity = '1', 10);
                
                // Remove after display duration
                setTimeout(() => {
                    avatar.style.opacity = '0';
                    setTimeout(() => avatar.remove(), 1000);
                }, CONFIG.AVATAR_DISPLAY_DURATION);
            }
            
            createFeedbackAvatar(ripple) {
                if (!document.getElementById('showAvatars').checked) return;

                const avatar = document.createElement('img');
                avatar.className = 'avatar avatar-pulse avatar-burst feedback-avatar';
                
                // Use the same avatar as the original extraction but with colored border for sentiment
                avatar.src = ripple.userData.avatar || '/public/img/testimonial-1.png';
                
                // Color based on sentiment
                const sentimentColors = {
                    'helpful': '#4ade80',      // Green
                    'neutral': '#fbbf24',      // Yellow  
                    'not-helpful': '#f87171'   // Red
                };
                
                avatar.style.border = `4px solid ${sentimentColors[ripple.userData.sentiment] || '#60a5fa'}`;
                avatar.style.borderRadius = '50%';
                avatar.style.width = CONFIG.AVATAR_SIZE + 'px';
                avatar.style.height = CONFIG.AVATAR_SIZE + 'px';
                avatar.style.objectFit = 'cover';
                
                const rect = this.gridManager.canvas.getBoundingClientRect();
                avatar.style.position = 'fixed';
                avatar.style.left = rect.left + ripple.centerNode.x - CONFIG.AVATAR_SIZE / 2 + 'px';
                avatar.style.top = rect.top + ripple.centerNode.y - CONFIG.AVATAR_SIZE / 2 + 'px';
                avatar.style.zIndex = '1000';
                
                document.body.appendChild(avatar);
                
                // Create smaller particle burst for feedback
                this.createFeedbackParticleBurst(ripple.centerNode, rect, sentimentColors[ripple.userData.sentiment]);
                
                // Fade in with pulse animation
                avatar.style.opacity = '0';
                avatar.style.transform = 'scale(0.5)';
                setTimeout(() => {
                    avatar.style.opacity = '1';
                    avatar.style.transform = 'scale(1)';
                    avatar.style.transition = 'all 0.3s ease-out';
                }, 10);
                
                // Remove after shorter duration
                setTimeout(() => {
                    avatar.style.opacity = '0';
                    avatar.style.transform = 'scale(0.8)';
                    setTimeout(() => avatar.remove(), 500);
                }, CONFIG.AVATAR_DISPLAY_DURATION * 0.7);
            }

            createParticleBurst(centerNode, rect) {
                if (!document.getElementById('particleEffects').checked) return;
                
                for (let i = 0; i < 8; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    const angle = (i / 8) * Math.PI * 2;
                    const distance = 30 + Math.random() * 20;
                    const endX = centerNode.x + Math.cos(angle) * distance;
                    const endY = centerNode.y + Math.sin(angle) * distance;
                    
                    particle.style.left = rect.left + centerNode.x + 'px';
                    particle.style.top = rect.top + centerNode.y + 'px';
                    particle.style.opacity = '1';
                    
                    document.body.appendChild(particle);
                    
                    // Animate particle
                    setTimeout(() => {
                        particle.style.transition = 'all 0.8s ease-out';
                        particle.style.left = rect.left + endX + 'px';
                        particle.style.top = rect.top + endY + 'px';
                        particle.style.opacity = '0';
                        
                        setTimeout(() => particle.remove(), 800);
                    }, 10);
                }
            }
            
            createFeedbackParticleBurst(centerNode, rect, color) {
                if (!document.getElementById('particleEffects').checked) return;
                
                // Create fewer, colored particles for feedback
                for (let i = 0; i < 5; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle feedback-particle';
                    particle.style.backgroundColor = color;
                    particle.style.width = '4px';
                    particle.style.height = '4px';
                    particle.style.borderRadius = '50%';
                    particle.style.position = 'fixed';
                    particle.style.pointerEvents = 'none';
                    particle.style.zIndex = '999';
                    
                    const angle = (i / 5) * Math.PI * 2;
                    const distance = 20 + Math.random() * 15;
                    const endX = centerNode.x + Math.cos(angle) * distance;
                    const endY = centerNode.y + Math.sin(angle) * distance;
                    
                    particle.style.left = rect.left + centerNode.x + 'px';
                    particle.style.top = rect.top + centerNode.y + 'px';
                    particle.style.opacity = '1';
                    
                    document.body.appendChild(particle);
                    
                    // Animate particle with star-like sparkle
                    setTimeout(() => {
                        particle.style.transition = 'all 0.6s ease-out';
                        particle.style.left = rect.left + endX + 'px';
                        particle.style.top = rect.top + endY + 'px';
                        particle.style.opacity = '0';
                        particle.style.transform = 'scale(2)';
                        
                        setTimeout(() => particle.remove(), 600);
                    }, 10);
                }
            }

            update(deltaTime) {
                // Update active ripples
                this.activeRipples = this.activeRipples.filter(ripple => {
                    const elapsed = Date.now() - ripple.startTime;
                    
                    if (ripple.phase === 'expanding') {
                        // Use ease-out curve for more organic movement
                        const progress = elapsed / CONFIG.RIPPLE_DURATION;
                        const easedProgress = 1 - Math.pow(1 - progress, CONFIG.EASING_POWER);
                        ripple.radius = easedProgress * ripple.maxRadius * CONFIG.rippleSpeed;
                        
                        if (elapsed >= CONFIG.RIPPLE_DURATION) {
                            ripple.phase = 'fading';
                            ripple.fadeStartTime = Date.now();
                        }
                    } else if (ripple.phase === 'fading') {
                        const fadeElapsed = Date.now() - ripple.fadeStartTime;
                        if (fadeElapsed >= CONFIG.RIPPLE_FADE_DURATION) {
                            ripple.phase = 'complete';
                            return false;
                        }
                    }
                    
                    // Apply ripple effect to nodes
                    this.applyRippleToNodes(ripple);
                    return true;
                });
                
                // Process queue
                while (this.rippleQueue.length > 0 && this.activeRipples.length < CONFIG.MAX_ACTIVE_RIPPLES) {
                    const queued = this.rippleQueue.shift();
                    if (queued.type === 'feedback') {
                        this.addFeedbackRipple(queued.centerNode, queued.userData);
                    } else {
                        this.addRipple(queued.centerNode, queued.userData, queued.intensity);
                    }
                }
            }

            applyRippleToNodes(ripple) {
                const { col: centerCol, row: centerRow } = ripple.centerNode;
                const currentRadius = Math.floor(ripple.radius);
                
                for (let r = -currentRadius; r <= currentRadius; r++) {
                    for (let c = -currentRadius; c <= currentRadius; c++) {
                        const distance = Math.sqrt(r * r + c * c);
                        if (distance <= ripple.radius) {
                            const node = this.gridManager.getNodeAt(centerCol + c, centerRow + r);
                            if (node) {
                                // Dramatic brightness falloff - brightest at center, fading more gradually
                                const normalizedDistance = distance / ripple.maxRadius;
                                const intensity = Math.max(0, 1 - Math.pow(normalizedDistance, 1.5));
                                
                                // Add extra brightness for center nodes
                                const centerBoost = distance < 2 ? (2 - distance) * 0.5 : 0;
                                let brightness = intensity + centerBoost;
                                
                                if (ripple.phase === 'fading') {
                                    const fadeProgress = (Date.now() - ripple.fadeStartTime) / CONFIG.RIPPLE_FADE_DURATION;
                                    const easedFade = Math.pow(fadeProgress, 0.8); // Slower fade start
                                    brightness *= (1 - easedFade);
                                }
                                
                                // Additive brightness for overlapping ripples
                                node.targetBrightness = Math.min(1, node.targetBrightness + brightness * 0.8);
                            }
                        }
                    }
                }
            }
        }

        // Statistics Manager
        class StatisticsManager {
            constructor() {
                this.stats = {
                    totalPromptsToday: 0,
                    totalExtractions: 0,
                    totalFeedback: 0,
                    activeUsers: new Set(),
                    promptTimestamps: [],
                    feedbackTimestamps: [],
                    peakActivity: { time: null, count: 0 },
                    averageRating: 0,
                    sentimentDistribution: { helpful: 0, neutral: 0, 'not-helpful': 0 }
                };
                this.updateUI();
            }

            addPrompt(userData) {
                this.stats.totalPromptsToday++;
                
                if (userData.type === 'extraction') {
                    this.stats.totalExtractions++;
                }
                
                // Add user info (name instead of email for enterprise tracking)
                this.stats.activeUsers.add(userData.user || userData.email);
                this.stats.promptTimestamps.push(Date.now());
                
                // Clean old timestamps (older than 1 hour)
                const oneHourAgo = Date.now() - 3600000;
                this.stats.promptTimestamps = this.stats.promptTimestamps.filter(ts => ts > oneHourAgo);
                
                // Update peak activity
                const currentHour = new Date().getHours();
                const promptsThisHour = this.stats.promptTimestamps.filter(ts => {
                    return new Date(ts).getHours() === currentHour;
                }).length;
                
                if (promptsThisHour > this.stats.peakActivity.count) {
                    this.stats.peakActivity = {
                        time: `${currentHour}:00`,
                        count: promptsThisHour
                    };
                }
                
                this.updateUI();
                this.updateActivityBar();
            }
            
            addFeedback(feedbackData) {
                this.stats.totalFeedback++;
                this.stats.feedbackTimestamps.push(Date.now());
                
                // Update sentiment distribution
                this.stats.sentimentDistribution[feedbackData.sentiment]++;
                
                // Update average rating
                const totalRatings = this.stats.sentimentDistribution.helpful + 
                                   this.stats.sentimentDistribution.neutral + 
                                   this.stats.sentimentDistribution['not-helpful'];
                                   
                this.stats.averageRating = (
                    (this.stats.sentimentDistribution.helpful * 4.5) +
                    (this.stats.sentimentDistribution.neutral * 3) +
                    (this.stats.sentimentDistribution['not-helpful'] * 1.5)
                ) / totalRatings;
                
                this.updateUI();
            }
            
            updateActiveUsers(count) {
                // This could be enhanced to track actual user objects
                // For now, just update the count
                if (count > this.stats.activeUsers.size) {
                    // Add placeholder users to match count
                    for (let i = this.stats.activeUsers.size; i < count; i++) {
                        this.stats.activeUsers.add(`User${i + 1}`);
                    }
                }
                this.updateUI();
            }

            getPromptsPerMinute() {
                const oneMinuteAgo = Date.now() - 60000;
                const recentPrompts = this.stats.promptTimestamps.filter(ts => ts > oneMinuteAgo);
                return recentPrompts.length;
            }

            updateUI() {
                document.getElementById('totalPrompts').textContent = this.stats.totalPromptsToday;
                document.getElementById('activeUsers').textContent = this.stats.activeUsers.size;
                document.getElementById('promptsPerMinute').textContent = this.getPromptsPerMinute().toFixed(1);
                document.getElementById('peakActivity').textContent = this.stats.peakActivity.time || '--:--';
            }

            updateActivityBar() {
                const activity = Math.min(this.getPromptsPerMinute() / 10, 1);
                document.getElementById('activityBar').style.width = `${activity * 100}%`;
            }
        }

        // Prompt Display Controller
        class PromptDisplayController {
            constructor() {
                this.currentPrompt = null;
                this.displayTimeout = null;
            }

            showPrompt(userData) {
                // Clear existing timeout
                if (this.displayTimeout) {
                    clearTimeout(this.displayTimeout);
                }
                
                const promptTextEl = document.getElementById('promptText');
                const promptUserEl = document.getElementById('promptUser');
                const promptDisplay = document.querySelector('.prompt-display');
                
                // Hide current content
                promptTextEl.classList.remove('show');
                promptUserEl.classList.remove('show');
                
                setTimeout(() => {
                    const promptText = userData.content || 'New prompt';
                    let displayText = promptText;
                    let lengthClass = 'short';
                    
                    // Determine how to display based on length
                    if (promptText.length <= 80) {
                        // Short prompts - single line with ellipsis
                        lengthClass = 'short';
                        displayText = promptText.length > 80 ? promptText.substring(0, 80) + '...' : promptText;
                    } else if (promptText.length <= 300) {
                        // Medium prompts - 3 lines max
                        lengthClass = 'medium';
                        displayText = promptText;
                    } else {
                        // Long prompts - scrollable area
                        lengthClass = 'long';
                        displayText = promptText;
                        
                        // Adjust display height for long prompts
                        promptDisplay.style.minHeight = '120px';
                    }
                    
                    // Remove previous length classes
                    promptTextEl.classList.remove('short', 'medium', 'long');
                    promptTextEl.classList.add(lengthClass);
                    
                    promptTextEl.textContent = displayText;
                    promptUserEl.textContent = userData.email || 'Anonymous';
                    
                    // Show with animation
                    promptTextEl.classList.add('show');
                    promptUserEl.classList.add('show');
                }, 100);
                
                // Longer display time for longer prompts
                const displayDuration = Math.min(CONFIG.PROMPT_DISPLAY_DURATION + (userData.content?.length || 0) * 20, 15000);
                
                // Auto-hide after duration
                this.displayTimeout = setTimeout(() => {
                    promptTextEl.classList.remove('show');
                    promptUserEl.classList.remove('show');
                    setTimeout(() => {
                        promptTextEl.textContent = '';
                        promptUserEl.textContent = '';
                        promptDisplay.style.minHeight = '80px'; // Reset height
                        promptTextEl.classList.remove('short', 'medium', 'long');
                    }, 500);
                }, displayDuration);
            }
        }

        // Background Particle System
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.createParticles();
            }

            createParticles() {
                for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                    this.createParticle();
                }
            }

            createParticle() {
                const particle = document.createElement('div');
                particle.className = 'background-particle';
                
                // Random position
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.top = Math.random() * window.innerHeight + 'px';
                
                // Random size
                const size = 1 + Math.random() * 2;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                
                // Random opacity
                particle.style.opacity = 0.1 + Math.random() * 0.3;
                
                document.body.appendChild(particle);
                
                // Animate
                this.animateParticle(particle);
                
                this.particles.push(particle);
            }

            animateParticle(particle) {
                const duration = 20000 + Math.random() * 10000;
                const startX = parseFloat(particle.style.left);
                const startY = parseFloat(particle.style.top);
                const endX = startX + (Math.random() - 0.5) * 200;
                const endY = startY - 100 - Math.random() * 200;
                
                particle.style.transition = `all ${duration}ms linear`;
                particle.style.left = endX + 'px';
                particle.style.top = endY + 'px';
                particle.style.opacity = '0';
                
                setTimeout(() => {
                    particle.remove();
                    this.particles = this.particles.filter(p => p !== particle);
                    
                    // Create new particle
                    if (document.getElementById('particleEffects').checked) {
                        this.createParticle();
                    }
                }, duration);
            }

            toggle(enabled) {
                if (!enabled) {
                    this.particles.forEach(particle => particle.remove());
                    this.particles = [];
                } else {
                    this.createParticles();
                }
            }
        }

        // Prompt Feed Manager
        class PromptFeed {
            constructor() {
                this.feedElement = document.getElementById('promptFeed');
                this.scrollElement = document.getElementById('promptFeedScroll');
                this.toggleButton = document.getElementById('promptFeedToggle');
                this.mainContent = document.getElementById('mainContent');
                this.resizeHandle = document.getElementById('resizeHandle');
                this.prompts = [];
                this.isVisible = false;
                this.scrollPosition = 0;
                this.autoScrollSpeed = 0.5; // pixels per frame
                this.maxPrompts = 50;
                this.currentWidth = 320;
                
                this.initializeToggle();
                this.initializeResize();
                this.startAutoScroll();
                this.updateTimestamps();
            }

            initializeToggle() {
                this.toggleButton.addEventListener('click', () => {
                    this.toggle();
                });
                
                // Add temp button listener
                document.getElementById('promptFeedToggleTemp').addEventListener('click', () => {
                    this.toggle();
                });
            }

            initializeResize() {
                let isResizing = false;
                let startX = 0;
                let startWidth = 0;

                this.resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startWidth = this.currentWidth;
                    
                    this.feedElement.classList.add('resizing');
                    document.body.style.cursor = 'ew-resize';
                    document.body.style.userSelect = 'none';
                    
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaX = e.clientX - startX;
                    let newWidth = startWidth + deltaX;
                    
                    // Clamp width between min and max
                    newWidth = Math.max(250, Math.min(600, newWidth));
                    
                    this.currentWidth = newWidth;
                    this.feedElement.style.width = newWidth + 'px';
                    
                    // Update main content margin
                    if (this.isVisible) {
                        this.mainContent.style.setProperty('--feed-width', newWidth + 'px');
                        this.mainContent.style.marginLeft = newWidth + 'px';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        this.feedElement.classList.remove('resizing');
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                });
            }

            toggle() {
                this.isVisible = !this.isVisible;
                
                if (this.isVisible) {
                    this.feedElement.classList.add('show');
                    this.mainContent.classList.add('with-feed');
                    this.mainContent.style.setProperty('--feed-width', this.currentWidth + 'px');
                    this.mainContent.style.marginLeft = this.currentWidth + 'px';
                    this.toggleButton.textContent = '✕';
                } else {
                    this.feedElement.classList.remove('show');
                    this.mainContent.classList.remove('with-feed');
                    this.mainContent.style.marginLeft = '';
                    this.toggleButton.textContent = 'FEED';
                }
            }

            addPrompt(userData) {
                const promptData = {
                    id: Date.now() + Math.random(),
                    user: userData.user || userData.email || 'Anonymous',
                    content: userData.content || userData.text || 'New prompt',
                    timestamp: userData.timestamp || new Date(),
                    profilePicture: userData.avatar || userData.profilePicture
                };

                this.prompts.push(promptData);
                
                // Limit number of prompts (remove oldest)
                if (this.prompts.length > this.maxPrompts) {
                    this.prompts = this.prompts.slice(-this.maxPrompts);
                }

                this.renderPrompts();
                
                // Auto-scroll to bottom to show newest prompt
                setTimeout(() => {
                    this.scrollElement.scrollTop = this.scrollElement.scrollHeight;
                }, 50);
            }

            renderPrompts() {
                // Clear existing content
                this.scrollElement.innerHTML = '';
                
                this.prompts.forEach((prompt, index) => {
                    const promptElement = this.createPromptElement(prompt, index);
                    this.scrollElement.appendChild(promptElement);
                    
                    // Trigger entrance animation for newest prompt (last in array)
                    if (index === this.prompts.length - 1) {
                        promptElement.classList.add('entering');
                        setTimeout(() => {
                            promptElement.classList.remove('entering');
                            promptElement.classList.add('recent');
                            
                            // Remove recent class after a delay
                            setTimeout(() => {
                                promptElement.classList.remove('recent');
                            }, 3000);
                        }, 50);
                    }
                    
                    // Add fading effect for older prompts (earlier in array)
                    if (index < this.prompts.length - 15) {
                        promptElement.classList.add('fading');
                    }
                });
            }

            createPromptElement(prompt, index) {
                const element = document.createElement('div');
                element.className = 'prompt-item';
                element.dataset.id = prompt.id;
                
                const timeAgo = this.getTimeAgo(prompt.timestamp);
                const truncatedContent = this.truncateText(prompt.content, 120);
                const avatarSrc = prompt.profilePicture || `https://ui-avatars.com/api/?name=${encodeURIComponent(prompt.user)}&background=60a5fa&color=fff&size=32`;
                
                element.innerHTML = `
                    <img class="prompt-avatar" src="${avatarSrc}" alt="${prompt.user}">
                    <div class="prompt-content">
                        <div class="prompt-header">
                            <div class="prompt-user">${prompt.user}</div>
                            <div class="prompt-time">${timeAgo}</div>
                        </div>
                        <p class="prompt-preview">${truncatedContent}</p>
                    </div>
                `;
                
                // Add click handler for interaction
                element.addEventListener('click', () => {
                    this.highlightPrompt(element);
                });
                
                return element;
            }

            truncateText(text, maxLength) {
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength).trim() + '...';
            }

            getTimeAgo(timestamp) {
                const now = new Date();
                const diff = Math.floor((now - timestamp) / 1000);
                
                if (diff < 60) return 'now';
                if (diff < 3600) return `${Math.floor(diff / 60)}m`;
                if (diff < 86400) return `${Math.floor(diff / 3600)}h`;
                return `${Math.floor(diff / 86400)}d`;
            }

            highlightPrompt(element) {
                // Remove previous highlights
                this.scrollElement.querySelectorAll('.prompt-item').forEach(item => {
                    item.style.background = '';
                });
                
                // Highlight selected prompt
                element.style.background = 'linear-gradient(135deg, rgba(96, 165, 250, 0.25) 0%, rgba(96, 165, 250, 0.15) 100%)';
                
                // Reset after delay
                setTimeout(() => {
                    element.style.background = '';
                }, 2000);
            }

            startAutoScroll() {
                let isScrolling = false;
                
                // Pause scrolling on hover
                this.scrollElement.addEventListener('mouseenter', () => {
                    isScrolling = true;
                });
                
                this.scrollElement.addEventListener('mouseleave', () => {
                    isScrolling = false;
                });
                
                const scroll = () => {
                    if (!isScrolling && this.isVisible && this.prompts.length > 0) {
                        const maxScroll = this.scrollElement.scrollHeight - this.scrollElement.clientHeight;
                        
                        // If we're at the bottom, scroll back to top
                        if (this.scrollPosition >= maxScroll) {
                            this.scrollPosition = 0;
                        } else {
                            this.scrollPosition += this.autoScrollSpeed;
                        }
                        
                        this.scrollElement.scrollTop = this.scrollPosition;
                    }
                    
                    requestAnimationFrame(scroll);
                };
                
                requestAnimationFrame(scroll);
            }

            updateTimestamps() {
                // Update timestamps every minute
                setInterval(() => {
                    const timeElements = this.scrollElement.querySelectorAll('.prompt-time');
                    timeElements.forEach((element, index) => {
                        if (this.prompts[index]) {
                            element.textContent = this.getTimeAgo(this.prompts[index].timestamp);
                        }
                    });
                }, 60000);
            }
        }

        // Main Application
        class PulseGridApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gridManager = new GridManager(this.canvas, CONFIG.GRID_COLS, CONFIG.GRID_ROWS);
                this.rippleEngine = new RippleEngine(this.gridManager);
                this.statsManager = new StatisticsManager();
                this.promptDisplay = new PromptDisplayController();
                this.particleSystem = new ParticleSystem();
                this.promptFeed = new PromptFeed();
                this.lastFrameTime = 0;
                this.isRunning = true;
                
                // Firebase connection state
                this.isFirebaseConnected = false;
                this.firebaseApp = null;
                this.db = null;
                this.extractionsUnsubscribe = null;
                this.feedbackUnsubscribe = null;
                this.usersUnsubscribe = null;
                
                // Settings
                this.rippleSpeed = 1.6;
                
                this.initializeSettings();
                this.initializeFirebase();
                this.startAnimationLoop();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('settingsPanel').classList.add('show');
                }, 1000);
                
                // Start demo mode only if Firebase is not connected
                setTimeout(() => {
                    if (!this.isFirebaseConnected) {
                        console.log('📱 Firebase not connected, starting demo mode...');
                        this.startDemoMode();
                    }
                }, 2000); // Give Firebase time to connect
            }

            initializeSettings() {
                // Settings panel toggle
                document.getElementById('settingsToggle').addEventListener('click', () => {
                    const panel = document.getElementById('settingsPanel');
                    const button = document.getElementById('settingsToggle');
                    
                    panel.classList.toggle('show');
                    button.classList.toggle('panel-open');
                });
                
                // Ripple speed control
                document.getElementById('rippleSpeed').addEventListener('input', (e) => {
                    CONFIG.rippleSpeed = parseFloat(e.target.value);
                });
                
                // Grid density control
                document.getElementById('gridDensity').addEventListener('input', (e) => {
                    const density = parseInt(e.target.value);
                    CONFIG.GRID_ROWS = density;
                    CONFIG.GRID_COLS = Math.floor(density * 1.67); // Maintain aspect ratio
                    this.gridManager = new GridManager(this.canvas, CONFIG.GRID_COLS, CONFIG.GRID_ROWS);
                    this.rippleEngine = new RippleEngine(this.gridManager);
                });
                
                // Particle effects toggle
                document.getElementById('particleEffects').addEventListener('change', (e) => {
                    this.particleSystem.toggle(e.target.checked);
                });
                
                // Window resize handler
                window.addEventListener('resize', () => {
                    this.gridManager.setupCanvas();
                    this.gridManager.initializeGrid();
                });
            }

            async initializeFirebase() {
                try {
                    console.log('🔥 Initializing Firebase for ChatGPT Enterprise Tracker...');
                    
                    // Real Firebase configuration
                    const firebaseConfig = {
                        apiKey: "AIzaSyBTnJYiMDXpw66ztcsADQ78lTllI5IkpdU",
                        authDomain: "chatgpt-extractor.firebaseapp.com",
                        projectId: "chatgpt-extractor",
                        storageBucket: "chatgpt-extractor.firebasestorage.app",
                        messagingSenderId: "229470439255",
                        appId: "1:229470439255:web:12200598158425efcce012",
                        measurementId: "G-XQEBYCEM11"
                    };
                    
                    // Initialize Firebase
                    this.firebaseApp = window.FirebaseApp.initializeApp(firebaseConfig);
                    
                    // Connect to specific database
                    this.db = window.FirebaseFirestore.getFirestore(this.firebaseApp, 'chatgpt-extractor-database');
                    
                    console.log('✅ Connected to chatgpt-extractor-database');
                    
                    // Set up real-time listeners
                    await this.setupFirestoreListeners();
                    
                    // Load initial data
                    await this.loadInitialData();
                    
                    this.isFirebaseConnected = true;
                    console.log('🎉 Firebase integration complete!');
                    
                } catch (error) {
                    console.error('❌ Firebase initialization failed:', error);
                    console.log('📱 Falling back to demo mode');
                    this.isFirebaseConnected = false;
                }
            }

            async setupFirestoreListeners() {
                const { collection, onSnapshot, query, orderBy, limit } = window.FirebaseFirestore;
                
                console.log('🔗 Setting up Firestore real-time listeners...');
                
                // Listen for new extractions (ChatGPT conversations)
                const extractionsQuery = query(
                    collection(this.db, 'extractions'),
                    orderBy('syncedAt', 'desc'),
                    limit(50)
                );
                
                this.extractionsUnsubscribe = onSnapshot(extractionsQuery, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const extraction = { id: change.doc.id, ...change.doc.data() };
                            this.handleNewExtraction(extraction);
                        }
                    });
                });
                
                // Listen for new feedback
                const feedbackQuery = query(
                    collection(this.db, 'feedback'),
                    orderBy('syncedAt', 'desc'),
                    limit(50)
                );
                
                this.feedbackUnsubscribe = onSnapshot(feedbackQuery, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const feedback = { id: change.doc.id, ...change.doc.data() };
                            this.handleNewFeedback(feedback);
                        }
                    });
                });
                
                // Listen for user activity
                const usersQuery = query(
                    collection(this.db, 'users'),
                    orderBy('lastActiveAt', 'desc')
                );
                
                this.usersUnsubscribe = onSnapshot(usersQuery, (snapshot) => {
                    this.handleUserUpdates(snapshot);
                });
                
                console.log('✅ Real-time listeners active');
            }
            
            async loadInitialData() {
                // This would be called once to populate initial state
                // The real-time listeners will handle new data
                console.log('📊 Loading initial data...');
            }
            
            handleNewExtraction(extraction) {
                console.log('📥 New ChatGPT conversation:', extraction.title);
                
                // Transform extraction data for visualization
                const firstMessage = extraction.messages && extraction.messages.length > 0 ? extraction.messages[0] : null;
                const promptText = firstMessage && firstMessage.role === 'user' ? firstMessage.content : extraction.title;
                
                const promptData = {
                    id: extraction.id,
                    text: extraction.title,
                    content: promptText, // First user message for the feed
                    user: extraction.threadOwner?.name || 'Unknown User',
                    organization: extraction.threadOwner?.organization || '',
                    avatar: this.generateAvatar(extraction.threadOwner?.name),
                    timestamp: new Date(extraction.syncedAt),
                    messageCount: extraction.messageCount,
                    url: extraction.url,
                    type: 'extraction'
                };
                
                // Add to statistics
                this.statsManager.addPrompt(promptData);
                
                // Add to prompt feed
                this.promptFeed.addPrompt(promptData);
                
                // Create ripple with size based on message count
                const centerNode = this.gridManager.getRandomNode();
                const rippleIntensity = Math.min(extraction.messageCount / 10, 1); // Scale 0-1
                this.rippleEngine.addRipple(centerNode, promptData, rippleIntensity);
                
                // Display prompt
                this.promptDisplay.showPrompt(promptData);
                
                // Special effects for milestones
                if (this.statsManager.stats.totalPromptsToday % 10 === 0) {
                    this.triggerMilestoneEffect();
                }
            }
            
            handleNewFeedback(feedback) {
                console.log('⭐ New feedback:', feedback.rating, 'stars');
                
                // Create feedback ripple with different visual style
                const feedbackData = {
                    id: feedback.id,
                    text: `${feedback.rating}⭐ - ${feedback.sentiment}`,
                    content: feedback.comment || `${feedback.rating}⭐ feedback on "${feedback.extraction?.title}"`,
                    user: 'Feedback',
                    avatar: this.getFeedbackAvatar(feedback.rating),
                    timestamp: new Date(feedback.syncedAt),
                    rating: feedback.rating,
                    sentiment: feedback.sentiment,
                    tags: feedback.tags,
                    type: 'feedback'
                };
                
                // Create smaller, colored ripple for feedback
                const centerNode = this.gridManager.getRandomNode();
                this.rippleEngine.addFeedbackRipple(centerNode, feedbackData);
                
                // Add to feed
                this.promptFeed.addPrompt(feedbackData);
                
                // Update statistics
                this.statsManager.addFeedback(feedbackData);
            }
            
            handleUserUpdates(snapshot) {
                const activeUsers = snapshot.size;
                this.statsManager.updateActiveUsers(activeUsers);
                console.log(`👥 Active users: ${activeUsers}`);
            }
            
            generateAvatar(name) {
                if (!name) return '/public/img/testimonial-1.png';
                
                // Generate consistent avatar based on name
                const avatars = [
                    '/public/img/testimonial-1.png',
                    '/public/img/testimonial-2.png',
                    '/public/img/testimonial-3.png'
                ];
                
                const hash = name.split('').reduce((a, b) => {
                    a = ((a << 5) - a) + b.charCodeAt(0);
                    return a & a;
                }, 0);
                
                return avatars[Math.abs(hash) % avatars.length];
            }
            
            getFeedbackAvatar(rating) {
                // Different avatar for different ratings
                if (rating >= 4) return '/public/img/testimonial-1.png'; // Happy
                if (rating >= 3) return '/public/img/testimonial-2.png'; // Neutral
                return '/public/img/testimonial-3.png'; // Concerned
            }

            triggerMilestoneEffect() {
                // Create spectacular wave effect from center outward
                const centerCol = Math.floor(CONFIG.GRID_COLS / 2);
                const centerRow = Math.floor(CONFIG.GRID_ROWS / 2);
                const maxDistance = Math.sqrt(centerCol * centerCol + centerRow * centerRow);
                
                // Create expanding rings
                let ring = 0;
                const createRing = () => {
                    this.gridManager.nodes.forEach(node => {
                        const distance = Math.sqrt(
                            Math.pow(node.col - centerCol, 2) + Math.pow(node.row - centerRow, 2)
                        );
                        
                        if (Math.abs(distance - ring) < 2) {
                            node.targetBrightness = 1;
                        }
                    });
                    
                    ring += 2;
                    if (ring < maxDistance) {
                        setTimeout(createRing, 100);
                    }
                };
                
                createRing();
                
                // Add celebration text
                const celebration = document.createElement('div');
                celebration.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 48px;
                    font-weight: bold;
                    color: #60a5fa;
                    text-shadow: 0 0 20px rgba(96, 165, 250, 0.8);
                    z-index: 100;
                    pointer-events: none;
                    animation: celebration 2s ease-out forwards;
                `;
                celebration.textContent = `🎉 ${this.statsManager.stats.totalPromptsToday} Prompts! 🎉`;
                document.body.appendChild(celebration);
                
                // Add celebration animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes celebration {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                        50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                    }
                `;
                document.head.appendChild(style);
                
                setTimeout(() => {
                    celebration.remove();
                    style.remove();
                }, 2000);
            }

            startAnimationLoop() {
                const animate = (currentTime) => {
                    if (!this.isRunning) return;
                    
                    const deltaTime = currentTime - this.lastFrameTime;
                    this.lastFrameTime = currentTime;
                    
                    // Update components
                    this.gridManager.update(deltaTime);
                    this.rippleEngine.update(deltaTime);
                    
                    // Render
                    this.gridManager.render();
                    
                    requestAnimationFrame(animate);
                };
                
                requestAnimationFrame(animate);
            }

            // Demo mode for testing without Firebase
            startDemoMode() {
                const demoUsers = [
                    { email: 'alice@deloitte.com', profilePicture: 'public/img/testimonial-1.png' },
                    { email: 'bob@deloitte.com', profilePicture: 'public/img/testimonial-2.png' },
                    { email: 'carol@deloitte.com', profilePicture: 'public/img/testimonial-3.png' },
                    { email: 'david@deloitte.com', profilePicture: 'public/img/testimonial-1.png' },
                    { email: 'emma@deloitte.com', profilePicture: 'public/img/testimonial-2.png' }
                ];
                
                const demoPrompts = [
                    'How can we optimize our supply chain using AI?',
                    'Generate a quarterly report template for client presentations',
                    'What are the latest trends in digital transformation?',
                    'Create a comprehensive risk assessment framework for cybersecurity that includes threat modeling, vulnerability analysis, incident response procedures, and compliance requirements for SOC 2, ISO 27001, and GDPR regulations. The framework should address both technical and organizational security measures.',
                    'Analyze the impact of remote work on productivity',
                    'Develop a detailed sustainability strategy for manufacturing operations that encompasses carbon footprint reduction, waste management optimization, renewable energy adoption, sustainable supply chain practices, and circular economy principles. Include specific KPIs, timeline milestones, and budget allocation recommendations for the next 5 years.',
                    'What are best practices for data governance?',
                    'Design a customer journey map for our new service',
                    'Please help me create a comprehensive digital transformation roadmap for a traditional retail company transitioning to omnichannel commerce. This should include technology stack recommendations, organizational change management strategies, employee training programs, customer experience optimization, data analytics implementation, and integration with existing legacy systems. The plan needs to address both short-term quick wins and long-term strategic objectives while considering budget constraints and risk mitigation.',
                    'I need assistance developing a machine learning model for predictive maintenance in manufacturing equipment. The solution should incorporate IoT sensor data, historical maintenance records, environmental factors, and operational parameters to predict equipment failures before they occur. Please outline the data preprocessing steps, feature engineering approaches, model selection criteria, validation methodology, and deployment strategy including real-time monitoring capabilities.',
                    'Create a detailed employee onboarding program that covers the first 90 days of employment, including orientation activities, training modules, mentorship assignments, goal setting, performance check-ins, and integration with company culture. The program should be scalable across different departments and roles while maintaining consistency in core company values and compliance requirements.'
                ];
                
                // Generate random prompts
                setInterval(() => {
                    const user = demoUsers[Math.floor(Math.random() * demoUsers.length)];
                    const prompt = demoPrompts[Math.floor(Math.random() * demoPrompts.length)];
                    
                    this.handleNewPrompt({
                        ...user,
                        content: prompt,
                        timestamp: Date.now()
                    });
                }, 3000 + Math.random() * 4000); // Random interval between 3-7 seconds
            }

            stop() {
                this.isRunning = false;
            }
        }

        // Initialize application when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.pulseGrid = new PulseGridApp();
        });
    </script>
    </div> <!-- End main-content -->
</body>
</html>